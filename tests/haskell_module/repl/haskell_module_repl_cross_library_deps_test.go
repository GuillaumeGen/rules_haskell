package haskell_module_repl_test

import (
	bt "github.com/bazelbuild/rules_go/go/tools/bazel_testing"
	it "github.com/tweag/rules_haskell/tests/integration_testing"
	"testing"
)

var testcase = `
-- WORKSPACE --
load("@bazel_tools//tools/build_defs/repo:http.bzl", "http_archive")
local_repository(
        name = "rules_haskell",
        path = "../rules_haskell",
)

load("@rules_haskell//haskell:repositories.bzl", "rules_haskell_dependencies")
load("@rules_haskell//tools:os_info.bzl", "os_info")

os_info(name = "os_info")

load("@os_info//:os_info.bzl", "is_windows")

rules_haskell_dependencies()
load("@rules_haskell//haskell:nixpkgs.bzl", "haskell_register_ghc_nixpkgs")

haskell_register_ghc_nixpkgs(
    attribute_path = "haskell.compiler.ghc8107",
    repository = "@rules_haskell//nixpkgs:default.nix",
    version = "8.10.7",
)

load("@rules_haskell//haskell:toolchain.bzl", "rules_haskell_toolchains")

rules_haskell_toolchains(version = "8.10.7")

load(
    "@io_tweag_rules_nixpkgs//nixpkgs:nixpkgs.bzl",
    "nixpkgs_cc_configure",
    "nixpkgs_python_configure",
    "nixpkgs_local_repository",
    "nixpkgs_package",
)

nixpkgs_cc_configure(
    name = "nixpkgs_config_cc",
    repository = "@rules_haskell//nixpkgs:default.nix",
)

nixpkgs_python_configure(
    repository = "@rules_haskell//nixpkgs:default.nix",
)

nixpkgs_local_repository(
    name = "nixpkgs_default",
    nix_file = "@rules_haskell//nixpkgs:default.nix",
)

load("@rules_haskell//haskell:cabal.bzl", "stack_snapshot")

stack_snapshot(
    name = "stackage",
    components = {},
    local_snapshot = "@rules_haskell//:stackage_snapshot.yaml",
    packages = ["base"],
    stack_snapshot_json = "@rules_haskell//:stackage_snapshot.json" if not is_windows else None,
    tools = [],
    vendored_packages = {
        "ghc-paths": "@rules_haskell//tools/ghc-paths",
    },
)
-- package-a/BUILD.bazel --
load("@rules_haskell//haskell/experimental:defs.bzl", "haskell_module")

# Load rules_haskell rules.
load(
    "@rules_haskell//haskell:defs.bzl",
    "haskell_library",
    "haskell_toolchain_library",
)

package(default_visibility = ["//visibility:public"])

haskell_toolchain_library(name = "base")


# gazelle_haskell_modules:srcs: src/
haskell_library(
    name = "package-a",
    ghcopts = [
    ],
    modules = [
        ":package-a.PackageA.Mod1",
        ":package-a.PackageA.Mod2",
    ],
    src_strip_prefix = "src",
    deps = [
        ":base",
    ],
)

# rule generated by gazelle_haskell_modules
haskell_module(
    name = "package-a.PackageA.Mod1",
    src = "src/PackageA/Mod1.hs",
    src_strip_prefix = "src",
)

# rule generated by gazelle_haskell_modules
haskell_module(
    name = "package-a.PackageA.Mod2",
    src = "src/PackageA/Mod2.hs",
    src_strip_prefix = "src",
    deps = [":package-a.PackageA.Mod1"],
)

-- package-a/src/PackageA/Mod1.hs --
module PackageA.Mod1 where

mod1num :: Int
mod1num = 2
-- package-a/src/PackageA/Mod2.hs --
module PackageA.Mod2 where

import PackageA.Mod1

mod2num :: Int
mod2num = mod1num * 3
-- package-b/BUILD.bazel --
load("@rules_haskell//haskell/experimental:defs.bzl", "haskell_module")

# Load rules_haskell rules.
load(
    "@rules_haskell//haskell:defs.bzl",
    "haskell_library",
    "haskell_toolchain_library",
)

package(default_visibility = ["//visibility:public"])

haskell_toolchain_library(name = "base")

# gazelle_haskell_modules:srcs: src/
haskell_library(
    name = "package-b",
    ghcopts = [
    ],
    modules = [
        ":package-b.PackageB.Mod1",
    ],
    narrowed_deps = ["//package-a"],
    src_strip_prefix = "src",
    deps =
        [":base"],
)

# rule generated by gazelle_haskell_modules
haskell_module(
    name = "package-b.PackageB.Mod1",
    src = "src/PackageB/Mod1.hs",
    cross_library_deps = ["//package-a:package-a.PackageA.Mod1"],
    src_strip_prefix = "src",
)
-- package-b/src/PackageB/Mod1.hs --
module PackageB.Mod1 (PackageB.Mod1.mod1num) where

import qualified PackageA.Mod2

mod1num :: Int
mod1num = PackageA.Mod2.mod2num * 7
`

func TestMain(m *testing.M) {
	it.TestMain(m, bt.Args{Main: testcase})
}

func TestHsModRepl(t *testing.T) {
	out, err := it.BazelOutput(it.Context.BazelBinary, "run", "//package-b:package-b@repl", "--", "-ignore-dot-ghci", "-e", "mod1num")
	if err != nil {
		t.Fatal(err)
	}
	it.AssertOutput(t, out, "42\n")
}
